---
title: "Analyse statistique avancée"
author: "OULEDI Victor, TORDJEMAN Robin, TREGOUET Yoann"
date: "2023-03-20"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

\begin{center}
M1 APE/RISE
\end{center}


\newpage

# Plan 

## 1) Introduction (en option) et description de la base

## 2) Statistiques descriptives

## 3) Spécification des différents modèles

- Régression estimateur EF
- Régression estimateur D1
- Régression between et pooling
- Choix entre EF et EA
- Choix entre D1 et within
- Estimations régresseurs constants avec within 

## 4) Conclusion

\newpage
# Introduction et description de la base

**Introduction Optionnelle**

La base de données à laquelle nous nous sommes intéressés se nomme "wagepan" et provient du package Wooldridge. Elle contient des informations sur les salaires et les caractéristiques des travailleurs aux États-Unis. Elle a été créée en compilant des données provenant d'enquêtes menées par le Département du Travail des États-Unis sur plusieurs années.La base  contient des milliers d'observations sur plusieurs années (545 individus de 1980 à 1987), ce qui permet d'analyser des tendances au fil du temps grâce à des techniques éconoétriques de données de panel.

Cette base de données est utilisée pour étudier les déterminants des salaires aux États-Unis. Les travaux économiques qui ont été réalisés sur cette base avaient pour but de comprendre comment des facteurs tels que l'éducation, l'expérience de travail, le genre, l'origine ethnique et d'autres variables liées à l'emploi influencent les salaires. Ils interrogeaint également des questions telles que la discrimination salariale et les différences de salaires entre les sexes et les différentes origines ethniques.Au total il est possible de s'appuyer sur 44 variables expliquatives pour la détermination de la variable "salaire" à expliquer

Les enjeux économiques abordés par cette base de données sont importants car les salaires sont un élément crucial du niveau de vie des travailleurs et de leur famille. Comprendre les facteurs qui influencent les salaires peut aider à identifier les politiques qui peuvent aider à améliorer les salaires et à réduire les inégalités salariales. 

# Description des variables

La base de données contient des variables qui ont été collectées à partir d'une enquête menée sur un échantillon de travailleurs américains entre 1985 et 1987. Ces variables comprennent des informations sur les caractéristiques des travailleurs et leurs salaires. On y retrouve :
"nr": l'identifiant de chaque individu
"year": l'année de l'enquête 
"age": l'âge du travailleur en années
"origin": l'origine ethnique du travailleur (hispanique, noir ou autre)
"educ": le niveau d'éducation du travailleur, mesuré en années d'études
"geo_zone" : la zone géographique du travailleur : sud, nord est ou nord ouest des États-Unis
"union": indique si le travailleur est membre d'un syndicat
"wage": le salaire horaire du travailleur en dollars
"hours": le nombre d'heures de travail hebdomadaires du travailleur
"exper": l'expérience professionnelle du travailleur en années
"married": indique si le travailleur est marié
"sector": indique le secteur d'activité du travailleur (agriculture, construction, manufacture, transport, trading, entertainment, professional relation services, business, finance, public services ou autre)
"poorhlth": état de santé du travailleur
"rur": indique si le travaille habite en zone rurale

```{r include=FALSE}
library(wooldridge)
```

```{r include=FALSE}
install.packages("wooldridge")
data("wagepan", package = "wooldridge")
```

# Statistiques descriptives


```{r include=FALSE}
wagepan$wage <- exp(wagepan$lwage)
```
Nous pouvons d'emblée nous intéresser aux statistiques descriptives de nos principales variables numériques avec la fonction summary.
 
```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(kableExtra)

wagepan_summary <- summary(wagepan[, c("hours", "educ", "wage", "lwage", "exper", "expersq")])

kable(wagepan_summary, align = "c", col.names = c("hours", "educ", "wage", "lwage", "exper", "expersq"))
```
On se rend compte qu'il y a tout de même de grandes différences entre les individues en termes d'années d'expérience, de salaires, d'heures exercées

Intéressons nous dans un second temps à la distribution des différents salaires : 

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(ggplot2)
ggplot(wagepan, aes(x = lwage)) + geom_histogram(aes(y=after_stat(density)), bins = 50, fill = "cyan4", color = "black", alpha = 0.5) + geom_density(color="darkred", lwd=1,alpha=0.5) + ggtitle("Graph 1 : Histogramme de la répartition des salaires") + geom_density(color="darkorange2", lwd=1,alpha=0.5) 
```
On peut déjà observer que ces derniers suivent plus ou moins une loi normale. Le travail économétrique sur les salaires sera d'autant plus adéquat avec des méthodes classiques.  

On créé ensuite des variables catégorielles à partir de nos variables muettes. On pourra ainsi réaliser des statistiques descriptives de ces dernières variables. 


```{r include=FALSE}
wagepan$secteur <- ifelse(wagepan$agric == 1, "agric", 
                           ifelse(wagepan$construc == 1, "construc",
                                  ifelse(wagepan$manuf == 1, "manuf",
                                         ifelse(wagepan$tra == 1, "transport",
                                                ifelse(wagepan$trad == 1, "trading",
                                                       ifelse(wagepan$ent == 1, "enter",
                                                              ifelse(wagepan$pro == 1, "prorel",
                                                                     ifelse(wagepan$bus == 1, "business",
                                                                            ifelse(wagepan$fin == 1, "fin",
                                                                                   ifelse(wagepan$pub == 1, "public", "autre"))))))))))


```

```{r echo=FALSE}
VA2<-which(wagepan$wage>40 | wagepan$wage<2)
wagepan <-wagepan[-VA2,]

library(ggplot2)
ggplot(wagepan, aes( y=wage,x=as.factor(secteur)))+
geom_boxplot(fill="indianred3")+ xlab(label = "secteur") + ylab(label = "wage") + ggtitle("Graph 2 : Boxplot des salaires en fonction du secteur") + theme(plot.title = element_text(family = "Times"))
```
On observe à travers ce booxplot que la plupart des salaires sont situés sous la barre des 10 dollars de l'heure. Il y a néanmoins beaucoup d'outliers vers qui représentent des salaires extrèmement élevés allant jsuqu'à presque  60 dollars de l'heure, cela pour plusieurs secteurs. 


```{r echo=FALSE}
sector_table <- table(wagepan$secteur)
lbls <- paste(names(sector_table), "\n", round(prop.table(sector_table) * 100, 1), "%")

par(mfrow = c(1, 2), cex = 0.7, mar = c(2,2,2,2)) 
pie(sector_table, labels = lbls, main = "Graph 3 : répartition des emplois", col = c("#4daf4a", "#a65628", "#e41a1c", "#ff7f00", "#984ea3", "#ffff33", "#f781bf", "#377eb8", "#999999", "#f0a3ff", "#00bfff"))

wagepan$origin <- ifelse(wagepan$black==1, "black",
                         ifelse(wagepan$hisp==1, "hisp", "other"))

wagepan$geo_zone <- ifelse(wagepan$nrthcen == 1, "center north",
                        ifelse(wagepan$nrtheast == 1, "north east", "other zones"))

wagepan$wage_categorie <- ifelse(wagepan$occ1 == 1, "occ1",
                                 ifelse(wagepan$occ2 == 1, "occ2",
                                        ifelse(wagepan$occ3 == 1, "occ3",
                                               ifelse(wagepan$occ4 == 1, "occ4",
                                                      ifelse(wagepan$occ5 == 1, "occ5",
                                                             ifelse(wagepan$occ6 == 1, "occ6",
                                                                    ifelse(wagepan$occ7 == 1, "occ7",
                                                                           ifelse(wagepan$occ8 == 1, "occ8",
                                                                                  ifelse(wagepan$occ9 == 1, "occ9", "other")))))))))


sector_table2 <- table(wagepan$origin)
lbls2 <- paste(names(sector_table2), "\n", round(prop.table(sector_table2) * 100, 1), "%")

par(mar=c(2, 2, 2, 0)) 
pie(sector_table2, labels = lbls2, cex=0.7, col = c("coral", "darkred","darkgoldenrod"))
title(main = "Graph 4 : origines ethniques")


```
Les pie-charts ci-dessus nous montrent la répartiion des emplois et des origines ethniques. On remarque que beaucoup des salariés observé travaillent dans les secteurs "trading" et "manufacture" et très peu dans les secteurs "entertainment" et "agriculture"

\newpage

```{r echo=FALSE, fig.align='center', fig.show='hold', message=FALSE, warning=FALSE}
wage_means <- aggregate(wage ~ secteur + year, data = wagepan, mean)
library(knitr)
library(reshape2)

result <- aggregate(wage ~ secteur + year, data = wagepan, mean)
result_wide <- dcast(result, secteur ~ year, value.var = "wage")

kable(result_wide, caption = "Tableau de moyennes salariales par secteur et année")
```


```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(ggplot2)
my_colors <- c("#4daf4a", "#a65628", "#e41a1c", "#ff7f00", "#984ea3", "#ffff33", "#f781bf", "#377eb8", "#999999", "#f0a3ff", "#00bfff")



my_colors <- c("#4daf4a", "#a65628", "#e41a1c", "#ff7f00", "#984ea3", "#ffff33", "#f781bf", "#377eb8", "#999999", "#f0a3ff", "#00bfff")
ggplot(wage_means, aes(x = year, y = wage, color = secteur)) +
  geom_line(size = 1) +
  scale_color_manual(values = my_colors) +
  labs(x = "Année", y = "Moyenne de la variable wage", color = "Catégorie") +
  ggtitle("Graph 5 : Evolution du salaire moyen par catégorie de 1980 à 1987")

ggplot(wage_means, aes(x = year, y = wage, fill = secteur)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = my_colors) +
  labs(x = "Année", y = "Graph 5 : Moyenne de la variable salair par secteur", fill = "Catégorie") +
  ggtitle("Graph 6 : Evolution de la part des salaires moyens par secteurs")

```

Graphiquement on peut dans un premier temps voir que les salaires moyens de chaques secteurs ont tous augmenté. Cependant, le graphique en  barre nous montre que le poids de chaque secteur dans le revenu total n'est  pas resté  constant.Certains secteur ayant vu leur masse salariale au sein de la somme des salaires augmenter au détriment d'autres secteurs. 


\newpage
Le graphique ci-dessous nous montre l'évolution du temps de travail. On remarque que le temps de travail a augmenté dans tous des secteurs. Les travailleurs du secteur "agriculture" travaillent plus que les autres. Cependant, leur temps de travail a légèrement diminué à partir de 1985. 

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(knitr)
library(reshape2)

result <- aggregate(hours ~ secteur + year, data = wagepan, mean)
result_wide <- dcast(result, secteur ~ year, value.var = "hours")

kable(result_wide, caption = "Tableau de moyennes d'heures éffectuées par secteur et année")
```



```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
my_colors <- c("#4daf4a", "#a65628", "#e41a1c", "#ff7f00", "#984ea3", "#ffff33", "#f781bf", "#377eb8", "#999999", "#f0a3ff", "#00bfff")

# Calculer la moyenne de la variable hour pour chaque catégorie et chaque année
hours_means <- aggregate(hours ~ secteur + year, data = wagepan, mean)

# Créer le graphique à lignes
ggplot(hours_means, aes(x = year, y = hours, color = secteur)) +
  geom_line(size = 1) +
  scale_color_manual(values = my_colors) +
  labs(x = "Année", y = "Moyenne de la variable wage", color = "Catégorie") +
  ggtitle("Graph 7 :Evolution du temps de travail par catégorie de 1980 à 1987")
```


```{r include=FALSE}
library(plm)
wi <- plm(lwage~exper+secteur+wagepan$geo_zone+union+hours+wagepan$poorhlth, data=wagepan, model = "within", index = "nr")
```


```{r include=FALSE}
fd<- plm(lwage~secteur+wagepan$geo_zone+union+hours+wagepan$poorhlth, data=wagepan, model = "fd", index = "nr")
```

```{r include=FALSE}
random<- plm(lwage~exper+secteur+married+origin+wagepan$geo_zone+union+educ+hours+wagepan$poorhlth, data=wagepan, model = "random", index = "nr")
```

\newpage
**Modèle théorique**
$lwage = \beta1_{education} + \beta2_{origine} + \beta3_{syndicalisation} + \beta4_{expérience} +\beta5_{secteur}$

# Régression within avec correction de white 

Dans un premier temps, nous utilisons un modèle à effet fixe avec une estimatation within. Spécifier un tel modèle implique d'émettre l'hypothèse que les effets individuels inobservés sont corrélés avec les variables explicatives.Pour notre thématique on pourrait ainsi supposer  que des effets individuels tels que la motivation peut par exemple conditionner le fait de poursuivre des études longues et ainsi infuencer les salaires plus tard. De même les carectéristiques génétiques individuelles peuvent être corrélées avec notre variable poorhealth qui traduit l'état de santé et peut potentiellement  avoir un impact sur la détermination du salaire. Dans notre modèle, l'utilisation de l'estimateur within permet de soustraire les moyennes individuelles de chaque unité de la variable d'intérêt, et ainsi contrôler les effets fixes non observables et  se concentrer sur les différences pour les régresseurs variables au fil du temps. Ainsi pour notre première régression nous ne pouvons pas estimer l'effet de régresseurs constant dans le temps, tels que l'origine ethnique ou le niveau d'étude. Cela voudrait dire que les résultats obtenus pour les effets des régresseurs variables dans le temps seront plus consitants que ceux pouvant être obtenus pour une spécification de modèle à effets aléatoires. 
```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(lmtest)

vcovHC.w <- vcovHC(wi,method="ar")
vcovHC.re <- vcovHC(random,method="ar")
vcovHC.fd <- vcovHC(fd,method="ar")
```

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(broom)
library(kableExtra)

results_coef <- coeftest(wi, vcov. = vcovHC.w)
results_df <- tidy(results_coef)

results_df$coefficients <- ifelse(results_df$p.value < 0.001, paste0(format(round(results_df$estimate,2), nsmall = 2), "***"), 
                                  ifelse(results_df$p.value < 0.01, paste0(format(round(results_df$estimate,2), nsmall = 2), "**"),
                                         ifelse(results_df$p.value < 0.05, paste0(format(round(results_df$estimate,2), nsmall = 2), "*"),
                                                format(round(results_df$estimate,2), nsmall = 2))))

kable_styling(kable(results_df, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)

resultswi_ci <- coefci(wi, vcov. = vcovHC) 
resultswi_df <- as.data.frame(resultswi_ci) 
kable_styling(kable(resultswi_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")
```





Avec la régression within, on obtient peu de variables qui ont un effet statistiquement significatif. selon ce modèle, Cela veut donc dire que valorisation d'une année d'experience a augmenté de 7% dans la détermination des salaires. Le nombre d'heures travaillées n'a pas d'impact sur le salaire horaire. On peut donc supposer que les personnes ayant travaillées plus d'heures n'ont pas reçu de valorisation salariales. Les personnes syndiquées gagnent en moyenne mieux leur vie que lorsqu'elles ne le sont pas. 
De même le salaire horaire des personnes travaillant dans le secteur financier a lui bien plus augmenté que celui des agriculteurs de 1980 à 1987 soit 17 points de pourcentage en plus. 

# Régression first difference avec correction de white 

Avec l'estimateur first difference (D1), étant donné que celui-ci implique la spécification d'un modèle à effet fixe (corrélation possible entre les effets fixes et les régresseurs), nous utilisons presque les mêmes régresseurs que pour le modèle estimé en within. En effet la principale différence entre un estimateur within et un estimateur "First-différence" est la façon dont ils contrôlent les effets fixes non observables et se concentrent sur les changements au fil du temps. L'estimation within soustrait les moyennes individuelles de chaque observation de la variable d'intérêt, tandis que l'estimation "First-différence" prend la différence entre les observations de deux périodes consécutives pour chaque unité individuelle dans les données. L'estimateur D1 nécessite une variation temporelle inconstante des variables explicatives pour chaque individu base son fonctionnement sur la variablité irrégulières Ainsi en vue de la méthode d'estimation, nous ne pouvons pas inclure la variable expérience qui a une évolution constante. Par définition elle augmente de une unité chaque année. Le modèle de différence première neutralise son effet et ne peut pas l'estimer correctement. 
```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(broom)
library(kableExtra)

resultscoef <- coeftest(fd, vcov. = vcovHC.fd)
resultscoef_df <- tidy(resultscoef)

resultscoef_df$coefficients <- ifelse(resultscoef_df$p.value < 0.001, paste0(format(round(resultscoef_df$estimate,3), nsmall = 2), "***"), 
                                      ifelse(resultscoef_df$p.value < 0.01, paste0(format(round(resultscoef_df$estimate,3), nsmall = 2), "**"),
                                             ifelse(resultscoef_df$p.value < 0.05, paste0(format(round(resultscoef_df$estimate,3), nsmall = 2), "*"),
                                                    format(round(resultscoef_df$estimate,3), nsmall = 2))))


kable_styling(kable(resultscoef_df, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)



```



```{r echo=FALSE}
resultsfd_ci <- coefci(fd, vcov. = vcovHC.fd) 
resultsfd_df <- as.data.frame(resultsfd_ci) 
kable_styling(kable(resultsfd_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")
```

La variable à évolution constante étant omise comparé au modèle à estimation within, on retrouve avec une regression first difference à peu pres les mêmes résultats que pour notre première régression. 

# Régression MCQG pour modèle à effet aléatoire avec correction de white 

L'estimateur MCQG pour le modèle à effets aléatoires permet de tenir compte des  caractéristiques  invariables dans le temps dans sa méthode de calcul. La spécification d'un modèle à effets aléatoire suppose cependant que les effets fixes individuels inobservés ne sont pas corrélés avec les variables explicatives. Autrement dit les résidus ne doivent pas être  corrélés avec les régresseurs. Ainsi les estimations pour ce modèle risquent d'être moins consistantes car les effets des variables non observées, tels que les compétences individuelles (motivation, détermination), ne sont pas pris en compte de manière appropriée car supposées non corrélées avec les régressuers. Ce modèle nous permettra d'estimer alors les effets des regresseurs constants dans le temps cette fois, tels que l'origine ethnique, le niveau d'étude, la situation maritale (nous considérons la variable comme constante étant donné qu'il y a peu de divorce sur les périodes observées). Nous utiliserons ensuite un test d'Hausman pour savoir si les résidus sont corrélés aux régresseurs. Les résultats du test nous permettront de savoir quelle spécification de modèle adopter.  A priori en vue de la thématique abordée, le modèle à spécifier s'apparenterait plus à un modèle à effet fixe. Les résultats obtenus grâce au modèle à effet aléatoire risquent donc de ne pas être fiables.  
```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(broom)
library(kableExtra)


resultsrdcoef<-coeftest(random, vcov. = vcovHC.re)
resultsrdcoef_df<-tidy(resultsrdcoef)


resultsrdcoef_df$coefficients <- ifelse(resultsrdcoef_df$p.value < 0.001, paste0(format(round(resultsrdcoef_df$estimate,3), nsmall = 2), "***"), 
                                 ifelse(resultsrdcoef_df$p.value < 0.01, paste0(format(round(resultsrdcoef_df$estimate,3), nsmall = 2), "**"),
                                        ifelse(resultsrdcoef_df$p.value < 0.05, paste0(format(round(resultsrdcoef_df$estimate,3), nsmall = 2), "*"),
                                               format(round(resultsrdcoef_df$estimate,3), nsmall = 2))))

kable_styling(kable(resultsrdcoef_df, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)

```


```{r echo=FALSE}
resultsrdci<-coefci(random, vcov. = vcovHC.re)
resultsrd_df<-as.data.frame(resultsrdci)
kable_styling(kable(resultsrd_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")
```

Avec ce dernier, plus de resultats sont statistiquement significatifs. D'après ce modèle, une année d'experience supplémentaire permet une augmentation du salaire de 0,36 dollars. Les regresseurs constant dansle temps sont aussi plus ou moins significatifs. On remarque que d'après ce modèle, les hispaniques gagnent en moyenne 0,75 dollars de l'heure de plus que les personnes noirs. Les personnes d'origine américaine ou autre gagnent en moyenne 0,79 dollars de plus que les personnes noires. On remarque également qu'une année d'étude supplémentaire créé une augmentation de salaire de à,68 dollars de l'heure en moyenne. Enfin, ce modèle nous dit également que le temps de travail n'a  pas d'impact sur le salaire horaire.

\newpage

# Regression en between
L'utilisation des estimateurs between et pooling fait l'hypothèse que les effets des variables explicatives sont les mêmes pour chaque individu. Ces hypothèses sont fortes et peu tenables dans un contexte réel, nous utiliserons les résultats des estimations en between et en pooling qu'à titre de comparaison avec des modèles plus appropriés.  
```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(plm)
library(broom)
library(kableExtra)

between <- plm(lwage ~ exper + married + origin + union + educ + hours + wagepan$poorhlth, data = wagepan, model = "between", index = "nr")
results_coef_between <- coeftest(between)
results_df_between <- tidy(results_coef_between)

results_df_between$coefficients <- ifelse(results_df_between$p.value < 0.001, paste0(format(round(results_df_between$estimate, 2), nsmall = 2), "***"), 
                                          ifelse(results_df_between$p.value < 0.01, paste0(format(round(results_df_between$estimate, 2), nsmall = 2), "**"),
                                                 ifelse(results_df_between$p.value < 0.05, paste0(format(round(results_df_between$estimate, 2), nsmall = 2), "*"),
                                                        format(round(results_df_between$estimate, 2), nsmall = 2))))

kable_styling(kable(results_df_between, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)

resultsbetween_ci <- coefci(between) 
resultsbetween_df <- as.data.frame(resultsbetween_ci) 
kable_styling(kable(resultsbetween_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")

```


\newpage
# Regression en pooling

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(plm)
library(broom)
library(kableExtra)

pooling <- plm(lwage ~ exper+ married + origin +union + educ + hours + wagepan$poorhlth, data = wagepan, model = "pooling", index = "nr")
results_coef <- coeftest(pooling, vcov. = vcovHC(pooling))
results_df <- tidy(results_coef)

results_df$coefficients <- ifelse(results_df$p.value < 0.001, paste0(format(round(results_df$estimate, 2), nsmall = 2), "***"), 
                                  ifelse(results_df$p.value < 0.01, paste0(format(round(results_df$estimate, 2), nsmall = 2), "**"),
                                         ifelse(results_df$p.value < 0.05, paste0(format(round(results_df$estimate, 2), nsmall = 2), "*"),
                                                format(round(results_df$estimate, 2), nsmall = 2))))

kable_styling(kable(results_df, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)

resultspooling_ci <- coefci(pooling, vcov. = vcovHC(pooling)) 
resultspooling_df <- as.data.frame(resultspooling_ci) 
kable_styling(kable(resultspooling_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")

```
**Test d'effets individuels**

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
plmtest(pooling) 
plmtest(pooling, type = "bp")
```
Pour notre thématique il est préférable de spécifier des modèles qui considère des effets individuels

\newpage
# Test d'Hausmann : Spécification d'un modèle à effet fixe ou effet aléatoire ? 

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(lmtest)
phtest(wi,random)
```
Il n'y alors que le modèle à effet fixe qui peut être estimé de manière consistente. Ce résultat est assez intuitif étant donné la thématique abordée, en effet les effets fixes individuels sont fortement corrélés avec certaines variables explicatives comme on l'a déjà expliqué. 
Nous allons devoir alors déterminer quel estimateur choisir entre le within et le D1 pour spécifier notre modèle à effet fixe. 
\newpage

# Within vs Différence Première
 
Dans un premier temps rappelons que l'estimateur différence première (D1) nécessite une variation temporelle des variables explicatives pour chaque individu. A l'inverse, l'estimateur à effet fixe within est lui souvent préférable à l'estimateur différence première dans les cas où il y a peu de variation temporelle des variables explicatives pour un individu donné. Cela peut arriver lorsque l'on utilise des données de panel où les individus sont suivis pendant une courte période de temps, comme pour le cas dans lequel nous nous trouvons. Nos variables explicatives varient peu également. Une partie de nos variables explicatives sont des dichotomiques constantes, et celles qui sont numériques continues ont une évolution assez constante. C'est le cas de l'expérience ou du nombre d'heure (voir statistiques descriptives). Nous penchons donc hypothétiquement pour l'estimateur within de préférence avant la validation par test. 

Dans un second temps, rappelons que pour les deux estimateurs, nous considérons les mêmes modèles avec des résidus $u_i$ corrélés avec nos régresseurs. Le calcul par estimateur within, pour un modèle à effet fixe, fait l'hypothèse que ces derniers ne sont pas corrélés entre eux au cours du temps. Il est de facto plus efficace que l'estimateur en différence première qui n'exige pas pour ses calculs la validation de cette hypothèse. Cependant dans de nombreux cas empiriques, ces résidus peuvent être de plus en plus corrélés au fil du temps, par exemple si les $u_i$ suivent une marche aléatoire.  Dans ce cas, leur valeur en période t dépend entièrement de leur valeur en t-1 plus un choc aléatoire. Cela implique qu'il y a un niveau de corrélation sérielle très fort et positif. Cependant les différentiels des $u_i$ ne sont pas corrélés, dans ce cas il sera préférable d'utiliser l'estimateur différence première. Dans de nombreux cas il existe une corrélation sérielle entre les $u_i$ mais bien moins forte que pour une marche aléatoire. Ainsi il sera difficile de faire un choix entre les 2 estimateurs.Il est difficile de tester si les $u_i$ sont corrélés suite aux estimations within. Cependant il est possible de voir si les différentiels des résidus obtenus en différence première le sont. Si ce n'est pas le cas, D1 pourra être utilisé. Si ces derniers différentiels sont négativement et sériellement corrélés on optera pour within (recommandation Wooldridge, voir annexe 1). Si le test ne se présente pas en faveur d'un estimateur plutot qu'un autre, en vue de la longueur de notre dimension temportelle et de l'évolution de nos variables explicatives nos opterons pour l'estimateur within.

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
pwfdtest(fd, h0="fe") 
pwfdtest(fd) 
```
On observe que pour le modèle considéré, les résidus sont caractérisés par de la corrélation sérielle. Cependant on observe que pour l'estimation D1 les différenciels des erreurs à chaque période comportent eux aussi de la corrélation sérielle. Dans ce cas nous obtons par l'estimateur within.  
\newpage

# Regression à modèle à effet fixe à estimateur within pour tester les effets de l'éducation sur l'évolution des salaires

Un problème se pose à nous maintenant : nous savons qu'en vue de la thématique abordée, un modèle à effet fixe avec une estimation within est plus approprié. Or, celui-ci ne permet pas de considérer des variables constantes dans le temps. Il est alors difficile pour nous de mesurer l'impact de ces dernières sur l'évolution des salaires. L'enjeu principal de la question d'étude étant de pouvoir quantifier les différentes dynamiques d'évolution des salaires entre différents groupes invariants dans le temps(origines ethniques ou niveau d'éducation)

S'il n'est pas possible de prendre en compte directement ces variables dans des modèles à effets fixes, il est tout de même possible de les considérer à travers leurs interractions avec d'autres variables inconstantes dans le temps et en particulier des variables dummy temporelles (effets combinés). C'est donc ce que nous avons spécifié pour la régression suivante. Nous avons introduit toutes les dummies temporelles exceptée celle pour notre période de référence. Il ne sera donc pas possible d'estimer les effets de l'éducation sur la détermination des salaires pour l'année 1980 qui est notre période de référence. 

De même en introduisant ces dummies annuelles, les effets des variables dont l'évolution est constante dans le temps deviennent inestimables. C'est le cas pour les effets de l'expérience professionnelle qui par définition augmente de une unité chaque année. 



```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE, eval=TRUE}
library(plm)
wibis <- plm(lwage~+married+exper+union+hours+wagepan$poorhlth+d81*educ+d82*educ+d83*educ+d84*educ+d85*educ+d86*educ+d87*educ, data=wagepan, model = "within", index = "nr")


vcovHC.wibis <- vcovHC(wibis, method = "ar")


results_coef_wibis <- coeftest(wibis, vcov. = vcovHC.wibis)
results_df_wibis <- tidy(results_coef_wibis)


results_df_wibis$coefficients <- ifelse(results_df_wibis$p.value < 0.001, paste0(format(round(results_df_wibis$estimate, 3), nsmall = 2), "***"),
                                      ifelse(results_df_wibis$p.value < 0.01, paste0(format(round(results_df_wibis$estimate, 3), nsmall = 2), "**"),
                                             ifelse(results_df_wibis$p.value < 0.05, paste0(format(round(results_df_wibis$estimate, 3), nsmall = 2), "*"),
                                                    format(round(results_df_wibis$estimate, 3), nsmall = 2))))


resultswibis_ci <- coefci(wibis, vcov. = vcovHC.wibis) 
resultswibis_df <- as.data.frame(resultswibis_ci) 


kable_styling(kable(results_df_wibis, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)


```


```{r fig.align='center', message=FALSE, warning=FALSE, include=TRUE}
kable_styling(kable(resultswibis_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")

```




**Résultats du test de Fisher**

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE, eval=TRUE}
library(plm)


# Obtenir la somme des carrés des résidus de la régression
SSR <- sum(resid(wibis)^2)

# Calculer le nombre de variables explicatives dans la régression
p <- ncol(wibis$coefficients) - 1

# Obtenir le nombre d'observations dans la régression
n <- nrow(wibis$wibis)

# Calculer le nombre de variables instrumentales s'il y en a
m <- length(wibis$psi)

# Calculer le test de Fisher
Ftest <- ((SSR - m) / m) / (SSR / (n - p - m))

# Calculer la valeur critique pour le test de Fisher avec un niveau de confiance de 95%
Fcrit <- qf(0.95, m, n - p - m)

# Afficher les résultats du test de Fisher
if (length(Fcrit) > 0 && Ftest > Fcrit) {
  cat("La significativité jointe de Fisher est atteinte. Le test de Fisher =", Ftest, ">", Fcrit)
} else {
  cat("La significativité jointe de Fisher n'est pas atteinte. Le test de Fisher =", Ftest, "<", Fcrit)
}
```

On voit bien que les effets estimés de l'éducation sont positifs et croissants au fil du temps. Les effets significatifs sont cependant ceux pour les dernières années d'observation avec par exemple une augmentation de la valorisation d'une année d'éducation d'environ 3 points de pourcentage en plus que pour l'année de référence, en ce qui concerne la détermination des salaires.  En terme d'interval de confiance on voit tout de même que la valorisation de l'éducation est sensiblement la même pour la détermination du salaire des individues des individus (faible écart type) et qu'elle a été revu à la hause (coefficients positifs est croissants)

Cependant, en réalisant un test de Fisher de significativité jointe on voit qu'on ne peut pas rejeter l'hypothèse que les effets joints des dummies annuelles combinés à ceux de l'éducation sont différents de 0 bien que 3 de ces effets combinés se soient révélés significatif individuellement. 

# Régression pour déterminer les effets de l'origine ethnique sur l'évolution des salaires

La méthode précédente nous ayant permis de surmonter le problème d'estimation de variables constantes dans le temps au sein d'un modèle à effet fixe, nous réitérons la méthodes pour estimer les effets de l'origine ethnique. 


```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE, eval=TRUE}
library(plm)
wagepan$other <- ifelse(wagepan$origin == "other", 1, 0)
witer <- plm(lwage~+married+exper+union+hours+wagepan$poorhlth+d81*black+d82*black+d83*black+d84*black+d85*black+d86*black+d87*black+ d81*hisp + d82*hisp + d83*hisp + d84*hisp + d85*hisp + d86*hisp + d87*hisp, data=wagepan, model = "within", index = "nr")


vcovHC.witer <- vcovHC(witer, method = "ar")


results_coef_witer <- coeftest(witer, vcov. = vcovHC.wibis)
results_df_witer <- tidy(results_coef_witer)


results_df_witer$coefficients <- ifelse(results_df_witer$p.value < 0.001, paste0(format(round(results_df_witer$estimate, 3), nsmall = 2), "***"),
                                      ifelse(results_df_witer$p.value < 0.01, paste0(format(round(results_df_witer$estimate, 3), nsmall = 2), "**"),
                                             ifelse(results_df_witer$p.value < 0.05, paste0(format(round(results_df_witer$estimate, 3), nsmall = 2), "*"),
                                                    format(round(results_df_witer$estimate, 3), nsmall = 2))))


resultswiter_ci <- coefci(witer, vcov. = vcovHC.witer) 
resultswiter_df <- as.data.frame(resultswiter_ci) 


kable_styling(kable(results_df_witer, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)



```

```{r fig.align='center', message=FALSE, warning=FALSE, include=TRUE}
kable_styling(kable(resultswiter_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")
```



La régression ne veut pas afficher les effets combinés des années aux origines ethnique. On a cependant une idée de l'interval de confiance de ces coefficients. On ne sait pas pourquoi la régression ne les affiche pas. 

Ainsi en se basant sur les intervals de confiance on peut tout de même se rendre compte que contrairement à l'éducation, l'effet de l'origine éthnique a été beaucoup plus disparatre. En effet au fil des années on voit que certaines personnes afro-américaines, et hispaniques ont été tres désavantagées au niveau des salaires alors que d'autres ont été tres avantagées par rapport aux autres orgines ethniques présupposées subir moins de discrimination. En effet, il y a grand écart type avec des effets de l'origines ethnique fortement postif et fortement négatif concernant l'évolution des salaires par rapport aux autres originies ethniques). 

Il reste cependant compliqué pour nous de tester la significativé de cette variable origine ethnique car n'ayant pas de résultats affichés pour la régression.

\newpage

# Spécification d'un Modèle Hausman-Taylor. 

Le modèle Hausman-Taylor est un modèle de panel  pour lequel on prend soin de préciser quels régresseurs sont corrélés avec effet fixes et lesquels sont invariants dans le temps. Pour celui-ci, l'instrumentalisation est utilisée pour résoudre ce problème d'endogénéité, ce qui peut conduire à une estimation biaisée des coefficients. Pour résoudre ce problème, on utilise des variables instrumentales. Cette instrumentalisation se fait par la transformation within des variables endogènes. Elle consiste a soustraire la moyenne temporelle des valeurs de la variable prises pour l'individu $i$ à la valeur de la variable pour ce même individu $i$ à chaque période. Or, si ces variables endogènes sont initialement corrélées avec les effets fixes, leur transformation ne l’est pas puisque la corrélation avec ces effets fixes ne peut être qu’avec la partie de la valeur du régresseur invariante dans le temps. Les variables variantes dans le temps et exogènes peuvent elles aussi subir une transformation within afin de les séparer de leur partie constante dans le temps. Apres que ces variables exogènes soient instrumentalisées, leur partie constante,elles, peuvent servir pour l'instrumentalisation des variables endogènes constantes dans le temps. 

Tout l'enjeu de la spécification de ce modèle reste de pouvoir estimer les regresseurs constant dans le temps. Or, apres toutes les instrumentalisations réalisées, si le nombre de régresseurs endogènes et variants dans le temps sont au moins égaux au nombre de régresseurs endogènes et constant dans le temps , il sera possible d'estimer ces régresseurs constant dans le temps. 

Dans notre cas nous supposons : 

- Variables endogènes : 
  - educ : éducation
  - exper : années d'expériences
  - union : syndicalisation
  - married : marié
  - secteur : secteurs d'activités
  
- Variables endogènes constantes : 
  - educ : éducation 
  
- Variables exogènes inconstantes : 
  - South : habite dans le sud
  - Nrthcen : habite dans le nord centrale
  - Nrtheast : habite dans le nord est
  - Poorhlth : est en mauvaise santé 
  
- Variables exogènes constantes :
  - Black : est afro-américain
  - Hisp : est d'origine hispanique
  

On se rend compte qu'on possède en effet plus de variables exogènes inconstantes que de variables endogènes constantes. On a donc assez d'instruments pour estimer pour estimer les régresseurs endogènes et exogènes constant. 



```{r eval=TRUE, echo=FALSE, fig.align='center', message=FALSE, warning=FALSE}
library(plm)
library(sandwich)
library(lmtest)
library(kableExtra)


ht <- pht(lwage ~ married + union + exper + wagepan$secteur + black + hisp + wagepan$nrthcen + wagepan$nrtheast + wagepan$south + wagepan$poorhlth + educ | black + hisp + wagepan$nrthcen + wagepan$nrtheast + wagepan$south + wagepan$poorhlth, data = wagepan, index = "nr")

results_coef_ht <- coeftest(ht)
results_df_ht <- tidy(results_coef_ht)

results_df_ht$coefficients <- ifelse(results_df_ht$p.value < 0.001, paste0(format(round(results_df_ht$estimate, 3), nsmall = 2), "***"),
                                      ifelse(results_df_ht$p.value < 0.01, paste0(format(round(results_df_ht$estimate, 3), nsmall = 2), "**"),
                                             ifelse(results_df_ht$p.value < 0.05, paste0(format(round(results_df_ht$estimate, 3), nsmall = 2), "*"),
                                                    format(round(results_df_ht$estimate, 3), nsmall = 2))))

resultsci_ht <- confint(ht)
resultsht_df <- as.data.frame(resultsci_ht)

kable_styling(kable(results_df_ht, digits = 2), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10)

```


```{r fig.align='center', message=FALSE, warning=FALSE, include=TRUE}
kable_styling(kable(resultsht_df), 
              full_width = FALSE, 
              latex_options = c("striped", "hold_position"),
              font_size = 10,
              position = "center")


```


Pour ce modèle on peut donc supposer que sur la période d'année éttudiée, la valorisation de l'éducation aurait augmenté de de 37 % de manière significative (95 %). De même l'impact de l'origine n'aurait pas été significative sur l'évolution des salaires. Les afro-américains auraient leur salaire évoluer 5 % de moins que la catégories autres autres origines ethniques. les hispaniques eux auraient vu leur salaire augmenter de 30% de plus que la catégorie autres origines ethniques, cependant il n'y a rien de significatif à ces estimations. 


# Conclusion. 

Pour résumer notre travail, nous avons dans un premier temps estimé des modèles classiques (within, différence première, effet aléatoire, between, pooling). Nous supposions que pour notre thématique d'étude, un modèle où les effets fixes et individuels étaientt corrélés avec les régresseurs était plus adapté. Nous avions alors du tester entre un modèle à estimer en within ou différence première. Nous avons donc opté pour un estiâteur within selon les conseils méthodologiques de Woolridge. 

Within une fois choisi, il nous était impossible d'estimer des effets de régresseurs constant dans le temps. Pour résoudre ce problème nous avons utilisé une méthode permettant de considérer les effets des régresseurs constants en les combinant avec des dummies temporelles. 

Dans un second temps nous avons aussi utilisé un modèle dynamique sous la spécification Hausman-Taylor. Les conditions pour pouvoir estimers les régresseurs constants étaient d'autant plus satisfaites. 

Il reste compliqué cependant de choisir un modèle en particulier. Nos 2 modèles les plus fiables restent le within et le Hausman-Taylor. Cependant en termes d'estimation, ces modèles fournissent des coefficients assez similaires (ex : la valorisation d'une année d'expérience aurait augmenté de 6% envrion par estimation within et de 5 % avec modèle Hausman-Taylor). Cependant en spécifiant un modèle Hausman Taylor et en comparant les résultat au modèle effets fixes within avec effets combinés avec dummies, on a des résultats assez différents. L'effet de l'éxpérience est assez différent 0,3 % d'augmentation de valorisation dans la détermination des salaires. Cet effet n'est pas significatif. De même les deux modèles permettent d'évaluer les effets de l'éducation (régresseur constant). on retrouve des résultats également très différents : la valorisation de l'éducation aurait augmenté de de 37 % de manière significative selon les estimations du modèle Hausman-Taylor. La valorisation d’une année d’éducation aurait elle augmenté d’environ 3 points de pourcentage par rapport à 1980 en 1987 selon les estimations du modèle within avec effets combinés. Les résultats de ce dernier modèle sont d'autant plus différents des autres modèles. Cependant sa spécification a été faite suite au instruction pédagogique de wooldridge (voir annexe 2). 

Ainsi face à ces résultats assez différents pour 2 modèles dont la pertinence théorique semble justifiée, il nous est bel et bien compliqué d'opter pour un en particulier. 


\newpage
# Bibliographie : 

F. Vella and M. Verbeek (1998), “Whose Wages Do Unions Raise? A Dynamic Model of Unionism and Wage Rate Determination for Young Men,” Journal of Applied Econometrics 13, 163-183. 

Wooldridge, J. M. (2003). Introductory Econometrics: A Modern Approach. South Western Educational Publishing.

Bound, J., & Johnson, G. (1992). Changes in the structure of wages in the 1980s: An evaluation of alternative explanations. American economic review, 82(3), 371-392.

Katz, L. F., & Murphy, K. M. (1992). Changes in relative wages, 1963-1987: Supply and demand factors. The Quarterly Journal of Economics, 107(1), 35-78.

\newpage
# Annexes : 

- Annexe 1 : Choix entre estimateur Within et différences premières 
- Annexe 2 : Spécification d'un modèle effets fixes avec utilisations d'effets combinés pour déterminer les effets des variables constantes











